import { Injectable, UnauthorizedException } from '@nestjs/common';
import { InjectRedis } from '@nestjs-modules/ioredis';
import { JwtService } from '@nestjs/jwt';

import Redis from 'ioredis';

import { AccessTokenPayload, RefreshTokenPayload } from '../interfaces';

@Injectable()
export class TokenService {
  private readonly REFRESH_TTL = 60 * 60 * 24 * 7; // 7 d√≠as

  constructor(
    @InjectRedis() private readonly redis: Redis,
    private jwtService: JwtService,
  ) {}

  async generateTokenPair(payload: AccessTokenPayload) {
    const accessToken = await this.jwtService.signAsync(payload, { expiresIn: '15min' });
    const refreshToken = crypto.randomUUID();

    const data: RefreshTokenPayload = {
      userId: payload.sub,
      clientId: payload.clientId,
      scope: payload.scope,
    };

    await this.redis.set(`refresh:${refreshToken}`, JSON.stringify(data), 'EX', this.REFRESH_TTL);
    await this.redis.sadd(`user_refresh_tokens:${payload.sub}`, refreshToken);

    return {
      accessToken,
      refreshToken,
      tokenType: 'Bearer',
      expiresIn: 900,
    };
  }

  async consumeRefreshToken(refreshToken: string) {
    const key = `refresh:${refreshToken}`;
    const raw = await this.redis.get(key);

    if (!raw) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    const data = JSON.parse(raw) as RefreshTokenPayload;

    await this.redis.del(key);
    await this.redis.srem(`user_refresh_tokens:${data.userId}`, refreshToken);

    return data;
  }

  async revokeAllForUser(userId: string) {
    const setKey = `user_refresh_tokens:${userId}`;
    const tokens = await this.redis.smembers(setKey);

    if (tokens.length === 0) return;

    const pipeline = this.redis.pipeline();

    for (const token of tokens) {
      pipeline.del(`refresh:${token}`);
    }

    pipeline.del(setKey);
    await pipeline.exec();
  }
}
